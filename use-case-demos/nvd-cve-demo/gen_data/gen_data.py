import csv
import random
import ipaddress
import uuid
import os

random.seed(42)  # For reproducibility
OUTPUT_DIR = "csv_data"

os.makedirs(OUTPUT_DIR, exist_ok=True)

NUM_SUBNETS = 20
NUM_INSTANCES = 1000
MIN_INTERFACES_PER_INSTANCE = 1
MAX_INTERFACES_PER_INSTANCE = 3
MIN_FINDINGS_PER_INSTANCE = 1
MAX_FINDINGS_PER_INSTANCE = 5

REGIONS = ["us-east-1", "us-west-2", "eu-north-1", "ap-southeast-1"]
AVAILABILITY_ZONES = {
    "us-east-1": ["us-east-1a", "us-east-1b", "us-east-1c"],
    "us-west-2": ["us-west-2a", "us-west-2b", "us-west-2c"],
    "eu-north-1": ["eu-north-1a", "eu-north-1b"],
    "ap-southeast-1": ["ap-southeast-1a", "ap-southeast-1b"]
}

def generate_cidr():
    network = ipaddress.IPv4Network("10.0.0.0/16")
    subnets = list(network.subnets(new_prefix=24))
    return str(random.choice(subnets))

# 1. Get CVE ID from cve.csv
cve_ids = []
with open("cve.csv", newline="", encoding="utf-8") as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        cve_ids.append(row["id"])

# 2. ec2_subnets.csv
subnets = []
for i in range(NUM_SUBNETS):
    subnet_id = f"subnet-{uuid.uuid4().hex[:16]}"
    region = random.choice(REGIONS)
    cidr_block = generate_cidr()
    available_ip_count = random.randint(50, 254)
    default_for_az = random.choice([True, False])
    map_customer_owned = random.choice([True, False])
    map_public = random.choice([True, False])
    az = random.choice(AVAILABILITY_ZONES[region])
    az_id = az.replace(region, region.replace("-", ""))  # Simplify AZ ID
    state = random.choice(["pending", "available"])
    assign_ipv6 = random.choice([True, False])
    subnets.append({
        "id": subnet_id,
        "region": region,
        "ownerid": f"{random.randint(100000000000, 999999999999)}",
        "cidr_block": cidr_block,
        "available_ip_address_count": available_ip_count,
        "default_for_az": default_for_az,
        "map_customer_owned_ip_on_launch": map_customer_owned,
        "map_public_ip_on_launch": map_public,
        "availability_zone": az,
        "availability_zone_id": az_id,
        "state": state,
        "assignipv6addressoncreation": assign_ipv6
    })

subnets_csv = os.path.join(OUTPUT_DIR, "ec2_subnets.csv")
with open(subnets_csv, "w", newline="", encoding="utf-8") as csvfile:
    fieldnames = list(subnets[0].keys())
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for row in subnets:
        writer.writerow(row)

# 3. ec2_instances.csv
instances = []
for i in range(NUM_INSTANCES):
    instance_id = f"i-{uuid.uuid4().hex[:16]}"
    imageid = f"ami-{uuid.uuid4().hex[:8]}"
    instancetype = random.choice(["t2.micro", "c4.large", "r4.large", "m5.large"])
    iami = f"arn:aws:iam::{subnets[0]['ownerid']}:instance-profile/{uuid.uuid4().hex[:8]}"
    launchtime = f"2024-{random.randint(1,12):02d}-{random.randint(1,28):02d}T{random.randint(0,23):02d}:{random.randint(0,59):02d}:00Z"
    launchtimeunix = random.randint(1600000000, 1700000000)
    monitoringstate = random.choice(["enabled", "disabled", "pending", "disabling"])
    state = random.choice(["running", "stopped", "terminated"])
    az = random.choice(AVAILABILITY_ZONES[subnets[0]["region"]])
    tenancy = random.choice(["default", "dedicated", "host"])
    architecture = random.choice(["x86_64", "arm64"])
    ebsoptimized = random.choice([True, False])
    bootmode = random.choice(["legacy-bios", "uefi"])
    lifecycle = random.choice(["", "spot", "scheduled"])
    hibernation = random.choice([True, False])
    instances.append({
        "id": instance_id,
        "imageid": imageid,
        "instancetype": instancetype,
        "iaminstanceprofile": iami,
        "launchtime": launchtime,
        "launchtimeunix": launchtimeunix,
        "monitoringstate": monitoringstate,
        "state": state,
        "availabilityzone": az,
        "tenancy": tenancy,
        "architecture": architecture,
        "ebsoptimized": ebsoptimized,
        "bootmode": bootmode,
        "instancelifecycle": lifecycle,
        "hibernationoptions": hibernation
    })

instances_csv = os.path.join(OUTPUT_DIR, "ec2_instances.csv")
with open(instances_csv, "w", newline="", encoding="utf-8") as csvfile:
    fieldnames = list(instances[0].keys())
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for row in instances:
        writer.writerow(row)

# 4. network_interfaces.csv å’Œ ec2_instance_interfaces.csv
interfaces = []
instance_interfaces = []
for inst in instances:
    num_ifaces = random.randint(MIN_INTERFACES_PER_INSTANCE, MAX_INTERFACES_PER_INSTANCE)
    for j in range(num_ifaces):
        eni_id = f"eni-{uuid.uuid4().hex[:16]}"
        mac = ":".join(f"{random.randint(0, 255):02x}" for _ in range(6))
        description = f"Interface {j+1} for {inst['id']}"
        private_ip = f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(1,254)}"
        private_dns = f"ip-{private_ip.replace('.', '-')}.ec2.internal"
        public_ip = f"{random.randint(52,54)}.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(1,254)}"
        status = random.choice(["available", "associated", "attaching", "in-use", "detaching"])
        subnet = random.choice(subnets)
        interface_type = random.choice(["interface", "efa"])
        source_dest = random.choice([True, False])
        interfaces.append({
            "id": eni_id,
            "mac_address": mac,
            "description": description,
            "private_ip_address": private_ip,
            "private_dns_name": private_dns,
            "public_ip": public_ip,
            "status": status,
            "subnetid": subnet["id"],
            "interface_type": interface_type,
            "source_dest_check": source_dest
        })
        instance_interfaces.append({
            "instance_id": inst["id"],
            "interface_id": eni_id
        })

interfaces_csv = os.path.join(OUTPUT_DIR, "network_interfaces.csv")
with open(interfaces_csv, "w", newline="", encoding="utf-8") as csvfile:
    fieldnames = list(interfaces[0].keys())
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for row in interfaces:
        writer.writerow(row)

instance_interfaces_csv = os.path.join(OUTPUT_DIR, "ec2_instance_interfaces.csv")
with open(instance_interfaces_csv, "w", newline="", encoding="utf-8") as csvfile:
    fieldnames = ["instance_id", "interface_id"]
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for row in instance_interfaces:
        writer.writerow(row)

# 5. aws_inspector_findings.csv
findings = []
for inst in instances:
    num_findings = random.randint(MIN_FINDINGS_PER_INSTANCE, MAX_FINDINGS_PER_INSTANCE)
    for k in range(num_findings):
        finding_arn = f"arn:aws:inspector:{subnets[0]['region']}:{subnets[0]['ownerid']}:finding/{uuid.uuid4().hex}"
        title = f"Finding {k+1} for {inst['id']}"
        status = random.choice(["ACTIVE", "RESOLVED"])
        severity = random.choice(["LOW", "MEDIUM", "HIGH", "CRITICAL"])
        first_obs = f"2025-{random.randint(1,6):02d}-{random.randint(1,28):02d}T{random.randint(0,23):02d}:{random.randint(0,59):02d}:00Z"
        last_obs = first_obs  # Simplified processing
        description = f"Description for {finding_arn}"
        finding_type = random.choice(["NETWORK_REACHABILITY", "PACKAGE_VULNERABILITY"])
        inspector_score = round(random.uniform(0, 100), 2)
        cvss_score = round(random.uniform(0, 10), 1) if finding_type == "PACKAGE_VULNERABILITY" else ""
        vulnerability_id = random.choice(cve_ids) if finding_type == "PACKAGE_VULNERABILITY" else ""
        findings.append({
            "id": finding_arn,
            "region": subnets[0]["region"],
            "title": title,
            "instance_id": inst["id"],
            "status": status,
            "severity": severity,
            "first_observed_at": first_obs,
            "last_observed_at": last_obs,
            "description": description,
            "finding_type": finding_type,
            "inspector_score": inspector_score,
            "cvss_score": cvss_score,
            "vulnerability_id": vulnerability_id
        })

findings_csv = os.path.join(OUTPUT_DIR, "aws_inspector_findings.csv")
with open(findings_csv, "w", newline="", encoding="utf-8") as csvfile:
    fieldnames = list(findings[0].keys())
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for row in findings:
        writer.writerow(row)

print("CSV files generated in directory:", OUTPUT_DIR)
print("- ec2_subnets.csv")
print("- ec2_instances.csv")
print("- network_interfaces.csv")
print("- ec2_instance_interfaces.csv")
print("- aws_inspector_findings.csv")
